"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _withDefaults = _interopRequireDefault(require("../utils/with-defaults"));

var _child = _interopRequireDefault(require("./child"));

var _jsxRuntime = require("react/jsx-runtime");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const defaultProps = {
  h1: false,
  h2: false,
  h3: false,
  h4: false,
  h5: false,
  h6: false,
  b: false,
  small: false,
  transform: 'none',
  i: false,
  span: false,
  del: false,
  em: false,
  blockquote: false,
  color: 'default'
};

const getModifierChild = (tags, children, size, transform) => {
  if (!tags.length) return children;
  const nextTag = tags.slice(1, tags.length);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_child.default, {
    tag: tags[0],
    size: size,
    transform: transform,
    children: getModifierChild(nextTag, children, size)
  });
};

const Text = ({
  h1,
  h2,
  h3,
  h4,
  h5,
  h6,
  b,
  small,
  i,
  span,
  del,
  em,
  blockquote,
  transform,
  size,
  margin,
  children,
  ...props
}) => {
  const elements = {
    h1,
    h2,
    h3,
    h4,
    h5,
    h6,
    blockquote
  };
  const inlineElements = {
    span,
    small,
    b,
    em,
    i,
    del
  };
  const names = Object.keys(elements).filter(name => elements[name]);
  const inlineNames = Object.keys(inlineElements).filter(name => inlineElements[name]);
  /**
   *  Render element "p" only if no element is found.
   *  If there is only one modifier, just rendered one modifier element
   *  e.g.
   *    <Text /> => <p />
   *    <Text em /> => <em />
   *    <Text b em /> => <b><em>children</em></b>
   */

  const tag = (0, _react.useMemo)(() => {
    if (names[0]) return names[0];
    if (inlineNames[0]) return inlineNames[0];
    return 'p';
  }, [names, inlineNames]);
  const renderableChildElements = inlineNames.filter(name => name !== tag);
  const modifers = (0, _react.useMemo)(() => {
    if (!renderableChildElements.length) return children;
    return getModifierChild(renderableChildElements, children, size, transform);
  }, [renderableChildElements, children, size, transform]);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_child.default, {
    transform: transform,
    tag: tag,
    margin: margin,
    size: size,
    ...props,
    children: modifers
  });
};

Text.toString = () => '.nextui-text';

const MemoText = /*#__PURE__*/_react.default.memo(Text);

var _default = (0, _withDefaults.default)(MemoText, defaultProps);

exports.default = _default;
module.exports = exports.default;