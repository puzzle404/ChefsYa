"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _radioContext = require("./radio-context");

var _collections = require("../utils/collections");

var _useWarning = _interopRequireDefault(require("../use-warning"));

var _useKeyboard = _interopRequireWildcard(require("../use-keyboard"));

var _radio = require("./radio.styles");

var _withDefaults = _interopRequireDefault(require("../utils/with-defaults"));

var _clsx = _interopRequireDefault(require("../utils/clsx"));

var _assertion = require("../utils/assertion");

var _jsxRuntime = require("react/jsx-runtime");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const defaultProps = {
  size: 'md',
  color: 'default',
  textColor: 'default',
  disabled: false,
  preventDefault: true
};
const preClass = 'nextui-radio';

const Radio = ({
  checked,
  onChange,
  disabled,
  color,
  size,
  textColor,
  value: radioValue,
  preventDefault,
  children,
  ...props
}) => {
  const [selfChecked, setSelfChecked] = (0, _react.useState)(!!checked);
  const {
    value: groupValue,
    disabledAll,
    inGroup,
    color: groupColor,
    size: groupSize,
    textColor: textGroupColor,
    updateState
  } = (0, _radioContext.useRadioContext)();
  const [withoutDescChildren, DescChildren] = (0, _collections.pickChild)(children, _radio.StyledRadioDescription);

  if (inGroup && _assertion.__DEV__) {
    if (checked !== undefined) {
      (0, _useWarning.default)('Remove props "checked" if in the Radio.Group.', 'Radio');
    }

    if (radioValue === undefined) {
      (0, _useWarning.default)('Props "value" must be deinfed if in the Radio.Group.', 'Radio');
    }
  }

  (0, _react.useEffect)(() => {
    setSelfChecked(groupValue === radioValue);
  }, [groupValue, radioValue]);
  const isDisabled = (0, _react.useMemo)(() => disabled || disabledAll, [disabled, disabledAll]);
  const radioColor = color !== 'default' ? color : groupColor;
  const radioSize = size !== 'md' ? size : groupSize;
  const labelColor = textColor !== 'default' ? textColor : textGroupColor;

  const changeHandler = event => {
    if (isDisabled || inGroup && selfChecked) return;
    const selfEvent = {
      target: {
        checked: !selfChecked
      },
      stopPropagation: event.stopPropagation,
      preventDefault: event.preventDefault,
      nativeEvent: event
    };
    setSelfChecked(!selfChecked);

    if (inGroup) {
      updateState && updateState(radioValue);
    }

    onChange && onChange(selfEvent);
  };

  const {
    bindings
  } = (0, _useKeyboard.default)(event => {
    changeHandler(event);
  }, [_useKeyboard.KeyCode.Enter, _useKeyboard.KeyCode.Space], {
    disableGlobalEvent: true,
    preventDefault
  });
  (0, _react.useEffect)(() => {
    if (checked === undefined) return;
    setSelfChecked(Boolean(checked));
  }, [checked]);
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_radio.StyledRadio, {
    "aria-checked": selfChecked,
    disabled: isDisabled,
    active: selfChecked,
    size: radioSize,
    color: radioColor,
    ...props,
    ...bindings,
    children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_radio.StyledRadioInput, {
      type: "radio",
      tabIndex: -1,
      value: radioValue,
      checked: selfChecked,
      onChange: changeHandler,
      className: `${preClass}-input`,
      ...props
    }), /*#__PURE__*/(0, _jsxRuntime.jsxs)(_radio.StyledRadioLabel, {
      color: labelColor,
      disabled: isDisabled,
      className: `${preClass}-name`,
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_radio.StyledRadioPoint, {
        tabIndex: isDisabled ? -1 : 0,
        className: (0, _clsx.default)(`${preClass}-point`, {
          [`${preClass}-active`]: selfChecked,
          [`${preClass}-disabled`]: isDisabled
        })
      }), withoutDescChildren]
    }), DescChildren && DescChildren]
  });
};

Radio.defaultProps = defaultProps;

if (_assertion.__DEV__) {
  Radio.displayName = 'NextUI - Radio';
}

Radio.toString = () => '.nextui-radio';

var _default = (0, _withDefaults.default)(Radio, defaultProps);

exports.default = _default;
module.exports = exports.default;